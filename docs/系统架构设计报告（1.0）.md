#  系统架构设计报告

## **1. 系统架构概述**

该项目是一个基于 Web 的开发者教育视频 CMS 系统，旨在为开发者提供一个视频平台，支持视频的上传、分享、评论与管理。整个系统采用**前后端分离**的架构，前端负责用户交互，后端负责业务逻辑和数据存储。系统具备较强的可扩展性、灵活性和高可用性，能够适应未来的功能扩展和用户增长。

### **1.1 系统架构图**

（此部分后续可以插入一张架构图，展示前端、后端、数据库、存储服务等模块的关系）

### **1.2 技术选型**

| 技术类别     | 选型                                                  |
| ------------ | ----------------------------------------------------- |
| 前端框架     | Vue 3 + Vite                                          |
| CSS 框架     | Tailwind CSS                                          |
| UI 组件库    | Naive UI                                              |
| 后端框架     | Express.js                                            |
| 身份验证     | Auth.js                                               |
| 存储服务     | Cloudinary（视频存储），Redis（缓存）                 |
| 数据库       | PostgreSQL                                            |
| 部署与容器化 | Vercel（前端部署）、VPS（后端部署），Docker（容器化） |
| 全栈语言     | TypeScript                                            |
| 日志监控     | LogRocket（前端），Prometheus + Grafana（后端）       |

## **2. 系统模块设计**

系统主要由前端和后端两个部分构成，前端负责用户界面的展示和交互，后端负责业务逻辑的处理、数据库的管理、存储的访问等。系统的主要模块包括：

### **2.1 前端模块**

前端主要功能包括：

- **视频展示**：推荐视频、热门视频、视频分类浏览
- **视频播放**：流畅的视频播放功能，支持高清和不同网络环境下的自适应播放
- **评论与互动**：用户可以对视频进行评论、点赞、收藏，建立互动
- **视频上传**：会员可以上传视频，并管理自己的个人频道
- **用户管理**：支持用户的注册、登录、个人信息设置等功能

### **2.2 后端模块**

后端功能包括：

- **身份认证与授权**：使用 Auth.js 实现用户的注册、登录、权限控制等功能
- **视频管理**：支持视频的上传、管理、审核、删除等
- **评论管理**：用户可对视频进行评论，管理员可删除评论
- **数据统计与分析**：记录用户行为数据、视频播放数据，并生成报告
- **管理员后台**：管理员可进行用户管理、视频审核、评论删除等操作

### **2.3 存储与缓存模块**

- **Cloudinary**：用于存储视频文件，支持高效的视频上传与优化
- **Redis**：用于缓存频繁访问的数据，如视频列表、评论等，提升系统性能

## **3. 数据库设计**

在本项目中，数据库是支撑整个系统运行的核心部分，它负责存储用户信息、视频信息、评论、标签等数据。设计合理的数据库架构，不仅能够确保系统的高效运行，还能为后期扩展和优化打下基础。以下是本系统的详细数据库设计。

### **3.1 数据库表设计**

#### **1. 用户表 (users)**

该表用于存储用户的基本信息，包括用户名、邮箱、密码、角色等数据。

| 字段名        | 类型                             | 描述                           |
| ------------- | -------------------------------- | ------------------------------ |
| id            | SERIAL                           | 主键，自增                     |
| username      | VARCHAR                          | 用户名，唯一                   |
| email         | VARCHAR                          | 用户邮箱，唯一                 |
| password_hash | TEXT                             | 加密的用户密码                 |
| role          | ENUM('guest', 'member', 'admin') | 用户角色（游客、会员、管理员） |
| avatar_url    | VARCHAR                          | 用户头像URL                    |
| bio           | TEXT                             | 用户个人简介                   |
| last_login    | TIMESTAMP                        | 最后登录时间                   |
| created_at    | TIMESTAMP                        | 用户创建时间                   |
| updated_at    | TIMESTAMP                        | 用户更新时间                   |

**设计说明**：

- `id`：每个用户的唯一标识。
- `role`：区分用户的不同权限（游客、会员、管理员）。
- `avatar_url`、`bio`：提供个性化的用户信息。
- `last_login`：记录用户的最近登录时间，便于统计用户活跃度。

#### **2. 视频表 (videos)**

该表用于存储视频的基本信息，包括标题、描述、上传者、视频文件路径等。

| 字段名        | 类型      | 描述                          |
| ------------- | --------- | ----------------------------- |
| id            | SERIAL    | 主键，自增                    |
| title         | VARCHAR   | 视频标题                      |
| description   | TEXT      | 视频描述                      |
| video_url     | VARCHAR   | 视频文件存储路径              |
| thumbnail_url | VARCHAR   | 视频封面图URL                 |
| duration      | INT       | 视频时长（单位：秒）          |
| uploader_id   | INT       | 外键，关联用户表的 id         |
| version       | VARCHAR   | 视频版本（例如：720p, 1080p） |
| created_at    | TIMESTAMP | 视频上传时间                  |
| updated_at    | TIMESTAMP | 视频更新时间                  |

**设计说明**：

- `video_url`：存储视频的实际文件路径。
- `thumbnail_url`：视频的封面图路径，用于展示。
- `uploader_id`：外键关联到用户表，用于标识视频的上传者。
- `version`：记录视频的质量（例如：720p、1080p）。

#### **3. 评论表 (comments)**

该表用于存储用户对视频的评论信息，包括评论内容、评论者、父评论等。

| 字段名            | 类型      | 描述                             |
| ----------------- | --------- | -------------------------------- |
| id                | SERIAL    | 主键，自增                       |
| user_id           | INT       | 外键，关联用户表的 id            |
| video_id          | INT       | 外键，关联视频表的 id            |
| content           | TEXT      | 评论内容                         |
| parent_comment_id | INT       | 父评论ID，支持多层级评论（可空） |
| likes_count       | INT       | 评论的点赞数                     |
| created_at        | TIMESTAMP | 评论时间                         |

**设计说明**：

- `parent_comment_id`：支持多层级的评论结构，用于回复评论。
- `likes_count`：记录评论的点赞数，便于对评论进行排序和展示。
- `content`：用户发表评论的内容。

#### **4. 视频审核表 (video_reviews)**

该表用于存储视频审核信息，包括审核状态、审核人员等。

| 字段名      | 类型                                    | 描述                          |
| ----------- | --------------------------------------- | ----------------------------- |
| id          | SERIAL                                  | 主键，自增                    |
| video_id    | INT                                     | 外键，关联视频表的 id         |
| reviewed_by | INT                                     | 外键，关联用户表的 id，审核员 |
| status      | ENUM('pending', 'approved', 'rejected') | 审核状态                      |
| created_at  | TIMESTAMP                               | 审核时间                      |

**设计说明**：

- `status`：记录视频的审核状态，主要有待审核（pending）、已通过（approved）、已拒绝（rejected）三种状态。
- `reviewed_by`：外键关联到用户表，记录审核员的ID。

#### **5. 视频标签表 (video_tags)**

该表用于存储视频的标签信息，帮助用户快速搜索和分类视频。

| 字段名   | 类型    | 描述                  |
| -------- | ------- | --------------------- |
| id       | SERIAL  | 主键，自增            |
| video_id | INT     | 外键，关联视频表的 id |
| tag      | VARCHAR | 标签名称              |

**设计说明**：

- `tag`：视频的标签，用于分类和视频搜索。

#### **6. 用户行为表 (user_activity)**

该表用于记录用户的行为数据，例如观看视频、点赞、评论等操作。

| 字段名      | 类型                                     | 描述                                   |
| ----------- | ---------------------------------------- | -------------------------------------- |
| id          | SERIAL                                   | 主键，自增                             |
| user_id     | INT                                      | 外键，关联用户表的 id                  |
| video_id    | INT                                      | 外键，关联视频表的 id                  |
| action_type | ENUM('view', 'like', 'comment', 'share') | 用户行为类型（观看、点赞、评论、分享） |
| created_at  | TIMESTAMP                                | 行为时间                               |

**设计说明**：

- `action_type`：记录用户的行为类型，可以是观看视频、点赞、评论或者分享。
- `video_id`：记录用户操作的目标视频，便于行为分析。

### **3.2 数据库设计总结**

通过上述表格的设计，我们确保了系统可以高效地管理用户信息、视频内容、评论、标签以及用户行为数据。这些表格不仅能支持基本的功能需求，还为后期扩展（例如增加视频推荐、用户行为分析、视频分类等）提供了足够的灵活性。

#### **数据关系**：

- 用户表与视频表通过 `uploader_id` 进行关联，确保每个视频都能追溯到上传的用户。
- 评论表通过 `user_id` 与视频表通过 `video_id` 进行关联，支持用户评论视频。
- 视频审核表通过 `video_id` 与视频表关联，确保视频审核状态的管理。
- 用户行为表通过 `user_id` 和 `video_id` 进行关联，记录用户的行为。

## **4. 前后端交互设计**

在设计前后端交互时，我们主要关注以下几个方面：

1. **API 设计**：后端的路由与前端的请求方式，确保数据传输的正确性。
2. **认证与权限管理**：不同角色（游客、会员、管理员）对 API 的访问控制。
3. **数据格式与请求类型**：设计 RESTful API，数据传输使用 JSON 格式。

### **4.1 前端与后端的路由映射**

以下是根据需求分析和数据库设计，我们的后端 API 路由设计：

#### **用户相关接口**

| HTTP 方法 | 路径               | 描述             | 角色        |
| --------- | ------------------ | ---------------- | ----------- |
| POST      | /api/auth/register | 用户注册         | 游客        |
| POST      | /api/auth/login    | 用户登录         | 游客        |
| POST      | /api/auth/logout   | 用户登出         | 会员/管理员 |
| GET       | /api/users/me      | 获取当前用户信息 | 会员/管理员 |
| PUT       | /api/users/me      | 更新当前用户信息 | 会员/管理员 |

**说明**：

- 用户注册与登录接口会使用 JWT（JSON Web Token）进行身份验证。
- `/api/auth/login` 会返回一个 JWT，用于后续 API 请求的身份验证。
- `/api/users/me` 用于获取和更新当前登录用户的信息，会员和管理员可以访问和修改自己的个人信息。

#### **视频相关接口**

| HTTP 方法 | 路径               | 描述             | 角色             |
| --------- | ------------------ | ---------------- | ---------------- |
| GET       | /api/videos        | 获取所有视频列表 | 游客/会员/管理员 |
| GET       | /api/videos/:id    | 获取单个视频信息 | 游客/会员/管理员 |
| POST      | /api/videos        | 上传视频         | 会员             |
| PUT       | /api/videos/:id    | 修改视频信息     | 会员/管理员      |
| DELETE    | /api/videos/:id    | 删除视频         | 会员/管理员      |
| GET       | /api/videos/search | 搜索视频         | 游客/会员        |

**说明**：

- `GET /api/videos` 和 `GET /api/videos/:id` 用于获取视频列表和单个视频的详细信息，所有用户都可以访问。
- `POST /api/videos` 用于视频上传，只有会员和管理员可以上传视频。
- `PUT /api/videos/:id` 和 `DELETE /api/videos/:id` 用于视频修改和删除操作，只有视频的上传者或管理员有权限操作。

#### **评论相关接口**

| HTTP 方法 | 路径                     | 描述                   | 角色        |
| --------- | ------------------------ | ---------------------- | ----------- |
| GET       | /api/videos/:id/comments | 获取某个视频的评论列表 | 游客/会员   |
| POST      | /api/videos/:id/comments | 添加评论               | 会员        |
| PUT       | /api/comments/:id        | 修改评论               | 会员/管理员 |
| DELETE    | /api/comments/:id        | 删除评论               | 会员/管理员 |

**说明**：

- `GET /api/videos/:id/comments` 用于获取视频的所有评论，任何人都可以查看。
- `POST /api/videos/:id/comments` 用于添加评论，只有会员及以上用户可以评论。
- `PUT /api/comments/:id` 和 `DELETE /api/comments/:id` 用于修改和删除评论，只有评论的作者或管理员可以操作。

#### **视频审核相关接口**

| HTTP 方法 | 路径                   | 描述                 | 角色   |
| --------- | ---------------------- | -------------------- | ------ |
| GET       | /api/videos/reviews    | 获取所有视频审核列表 | 管理员 |
| POST      | /api/videos/:id/review | 提交视频审核         | 管理员 |
| PUT       | /api/videos/:id/review | 修改视频审核状态     | 管理员 |

**说明**：

- `GET /api/videos/reviews` 用于管理员查看所有视频的审核状态。
- `POST /api/videos/:id/review` 用于管理员提交视频审核。
- `PUT /api/videos/:id/review` 用于管理员修改视频审核状态（通过、拒绝等）。

#### **用户行为统计接口**

| HTTP 方法 | 路径                  | 描述                   | 角色   |
| --------- | --------------------- | ---------------------- | ------ |
| GET       | /api/users/activities | 获取用户的行为统计数据 | 管理员 |
| GET       | /api/videos/stats     | 获取视频的观看数据     | 管理员 |

**说明**：

- `GET /api/users/activities` 用于获取用户的行为数据（如评论、点赞等），仅管理员可访问。
- `GET /api/videos/stats` 用于获取视频的统计数据（如观看次数、点赞数等），仅管理员可访问。

### **4.2前后端交互流程**

在前后端交互过程中，我们需要确保数据的传输方式、请求格式和响应格式都能满足系统的需求，特别是在权限控制和认证方面的考虑。以下是前后端交互的详细设计，涵盖了主要的功能模块。

#### **用户认证流程**

用户认证是所有请求的基础，确保用户身份的安全性。所有需要身份验证的接口都需要在请求头中携带有效的 JWT。

- **前端操作**：
  - 在用户登录时，前端通过 `POST /api/auth/login` 提交用户名和密码，成功后收到 JWT。
  - 这个 JWT 会存储在客户端（通常存储在 `localStorage` 或 `sessionStorage` 中），并在后续的请求中携带。
- **后端处理**：
  - 后端的所有需要认证的接口会通过 `authenticateJWT` 中间件来验证 JWT 的有效性，确保请求来自合法用户。

####  视频操作流程

视频是系统的核心功能，前端和后端的交互设计要确保视频上传、观看、管理和审核功能的正常工作。

- **前端操作**：
  - 用户在浏览视频时，前端会发起 `GET /api/videos` 或 `GET /api/videos/:id` 请求，获取视频数据。
  - 当会员上传视频时，前端会通过 `POST /api/videos` 接口上传视频，上传过程中需要提供视频的标题、描述等信息，并确保视频文件符合要求。
- **后端处理**：
  - 后端会通过 `POST /api/videos` 接口接收视频文件并保存到服务器或云存储中。
  - 后端会对上传的视频进行基本的处理，如生成缩略图、保存视频元数据到数据库等。
  - 管理员可以通过 `GET /api/videos/reviews` 来查看需要审核的视频，并通过 `POST /api/videos/:id/review` 审核视频。

#### **评论操作流程**

评论功能是用户与内容互动的重要方式，前后端需要协调一致，确保评论能够正常显示与管理。

- **前端操作**：
  - 用户在视频播放页面输入评论，前端会通过 `POST /api/videos/:id/comments` 接口提交评论内容。
  - 用户可以查看视频的所有评论，前端会发起 `GET /api/videos/:id/comments` 请求获取评论列表。
- **后端处理**：
  - 后端会接收到评论请求，并保存评论到数据库中，同时关联到对应的视频。
  - 后端会返回评论的相关信息，并支持评论的修改和删除操作，管理员可以删除不当评论。

#### **权限控制与数据安全**

前后端交互设计中最重要的部分是权限控制。不同角色的用户应当访问不同的数据和功能。我们通过 JWT 和中间件来进行权限控制。

- **前端操作**：
  - 对于会员和管理员，前端在请求时会携带 JWT，以便后端验证用户身份并确定是否有权限进行相关操作。
- **后端处理**：
  - 后端根据用户的角色（如通过 JWT 中的信息）来控制权限。只有管理员可以进行视频审核、删除评论、查看统计数据等操作。

#### 数据流与交互

以下是前后端交互的简要数据流示意：

1. **登录认证**：
   - 前端通过表单提交用户名和密码到 `/api/auth/login`，后端验证成功后返回 JWT。
   - 前端存储 JWT，并在后续请求中通过请求头发送 `Authorization: Bearer <JWT>`。
2. **获取视频列表**：
   - 前端发送 `GET /api/videos` 请求，后端返回视频数据列表。
3. **视频上传**：
   - 前端通过 `POST /api/videos` 上传视频文件，后端接收并存储视频文件。
   - 后端处理后，返回上传成功的视频信息。
4. **评论添加**：
   - 前端用户提交评论时，发送 `POST /api/videos/:id/comments`，后端保存评论并返回更新后的评论列表。
5. **视频审核**：
   - 后端管理员可以通过 `POST /api/videos/:id/review` 提交视频审核，后端处理后返回审核结果。
6. **权限验证**：
   - 每个需要权限验证的接口，都要求在请求中携带有效的 JWT。后端使用 `authenticateJWT` 中间件进行验证，并根据 JWT 中的信息判断用户角色是否有权限进行操作。

### **4.4 总结**

1. **身份认证与权限控制**：通过 JWT 实现身份认证，确保不同角色的用户只能够访问和操作他们有权限的资源。
2. **API 设计**：设计了 RESTful API，确保前后端的高效数据交互。所有请求与响应使用 JSON 格式。
3. **前后端协作**：通过明确的 API 请求和响应格式，确保前端能够与后端无缝对接，提供良好的用户体验。

## **5. 系统安全设计**

系统安全是 Web 应用的一个至关重要的部分，尤其是在涉及用户数据、视频内容等敏感信息时，必须采取一系列有效的措施来确保数据的机密性、完整性与可用性。以下是针对系统安全的详细设计方案：

### **5.1 身份认证与授权**

为了确保每一个操作都有合法的用户身份验证，系统将使用 **JWT（JSON Web Token）** 和 **Auth.js** 来进行身份认证和授权。

#### **JWT 认证流程**：

1. **用户登录**：
   - 用户提交用户名和密码，通过 `POST /api/auth/login` 接口登录。
   - 后端验证用户的用户名和密码，若验证通过，则使用 JWT 签发一个 token，返回给前端。
   - JWT 将包含用户的唯一标识（如用户 ID）、角色信息（如游客、会员、管理员）和过期时间等信息。
2. **请求携带 Token**：
   - 用户在进行需要身份验证的请求时，前端会将 token 放在 HTTP 请求的 **Authorization** 头中，格式为 `Bearer <token>`。
   - 例如：`Authorization: Bearer <token>`。
3. **后端验证 Token**：
   - 后端通过中间件 **authenticateJWT** 验证请求头中的 token 是否有效。
   - 如果 token 验证通过，后端会从 token 中提取用户信息（如用户 ID 和角色）并在请求的上下文中传递，以便后续业务逻辑使用。
   - 如果 token 验证失败，返回 401 Unauthorized 错误，提示用户重新登录。
4. **权限控制**：
   - 后端会根据用户的角色（存储在 JWT 中）进行权限校验，确保用户只能访问其有权限的资源。
   - 比如，管理员可以访问所有视频、用户和评论数据，会员可以上传视频和评论，游客仅能浏览视频。

#### **Auth.js**

- 使用 **Auth.js** 来简化身份验证流程，支持多种认证方式（如邮件、OAuth 2.0 等），并为系统提供安全的身份管理功能。
- 它可以帮助我们快速实现安全的用户注册、登录、会话管理和 JWT 生成等功能。

### **5.2 数据加密与保护**

#### **密码加密**：

- **bcrypt**：系统将使用 **bcrypt** 算法来对用户密码进行加密，确保即使数据库泄漏，密码也无法被直接读取。加密过程包括两步：

  1. **盐值（Salt）**：在密码加密时，使用 **bcrypt** 为每个密码生成唯一的盐值，确保即使两个用户使用相同的密码，其加密结果也是不同的。
  2. **加密算法**：bcrypt 使用强大的加密算法生成密码的哈希值，并将其存储在数据库中。即使数据库被攻破，黑客也只能看到加密后的哈希值，而无法逆向还原出明文密码。

  **存储密码的步骤**：

  - 用户注册时，前端提交密码，后端使用 **bcrypt** 进行加密，并将加密后的密码存储在数据库中。
  - 用户登录时，后端对提交的密码进行加密，并与数据库中存储的哈希值进行比对，如果匹配则验证通过。

#### **敏感数据保护**：

- 对于敏感数据（如密码、视频文件路径、用户个人信息等），在存储和传输过程中要采取加密措施：
  - **传输加密**：使用 **HTTPS** 来保证前后端数据传输的安全，防止中间人攻击。
  - **加密存储**：对于敏感信息，使用 **AES 加密算法** 进行加密存储，确保数据即使被盗取也无法被直接读取。

### **5.3 防止恶意攻击**

#### **防止 SQL 注入**：

- 使用 **ORM（对象关系映射）** 工具（如 **Sequelize** 或 **Prisma**）来避免直接拼接 SQL 查询，减少 SQL 注入攻击的风险。ORM 提供了自动化的查询构建器，能有效避免因手动拼接 SQL 语句而导致的注入漏洞。
  - 例如，使用 ORM 查询时，自动将用户输入的数据进行转义，防止恶意 SQL 代码注入。

#### **防止 XSS 攻击**：

- **输入过滤与 HTML 编码**：所有用户输入的内容（如评论、视频标题、描述等）在提交到数据库前，都需要经过严格的 **输入过滤**，以防止恶意的 JavaScript 代码注入。
  - 使用 **DOMPurify** 或其他库来清除输入中的 HTML 标签或脚本代码。
  - 在呈现数据时，前端应使用 **HTML 编码** 或 **模板引擎**（如 Vue.js）来自动转义用户输入，防止浏览器执行恶意脚本。

#### **防止 CSRF 攻击**：

- **CSRF Token**：为了防止 CSRF 攻击，前端在每个需要改变数据的请求中都会携带一个 **CSRF Token**。这个 token 会在用户登录时生成，并随着每个后续请求一起提交。
  - 后端会验证每个请求中的 CSRF Token 是否有效，确保请求是由用户主动发起的，而非由恶意第三方发起。
  - 在 POST、PUT、DELETE 等请求中，前端将自动添加 CSRF token，后端会在请求头中验证该 token 的有效性。

### **5.4 安全日志与监控**

为了及时发现潜在的安全威胁，系统还应该进行安全日志的记录与实时监控。

- **安全日志**：后端记录用户登录、操作（如视频上传、评论删除等）和权限变更等操作的日志，并确保日志的不可篡改性。
  - 日志中应包含用户身份、时间戳、操作类型、操作对象等信息。
- **实时监控**：使用 **Prometheus** 和 **Grafana** 等工具进行后端的安全监控，实时监控请求的来源、异常请求、登录失败次数等。
  - 通过设置阈值警告，防止暴力破解和其他恶意行为。

### **总结**

1. **身份认证与授权**：通过 JWT 和 Auth.js 实现安全的用户身份认证与授权，确保每个请求都能获得正确的用户权限。
2. **数据加密与保护**：使用 bcrypt 加密存储用户密码，采取 HTTPS 和 AES 加密确保数据传输和存储安全。
3. **防止恶意攻击**：通过使用 ORM、输入过滤、HTML 编码、防 CSRF Token 等措施有效防止 SQL 注入、XSS 和 CSRF 攻击。
4. **安全日志与监控**：记录关键操作的安全日志，并进行实时监控，确保能够及时发现并应对潜在的安全威胁。

通过这些安全设计，我们可以确保系统在面对各种网络攻击时具有较强的抵御能力，保障用户数据和应用的安全。

## **6. 可扩展性设计**

为了确保系统能够在未来需求增长时轻松扩展，我们采取了以下几种设计策略。这些策略不仅能支持现有功能的扩展，还能确保新功能的平滑集成。

### **6.1 微服务架构**

随着业务的逐步增长，系统的某些模块可能会变得复杂或需要独立扩展。为此，采用 **微服务架构** 是一种非常理想的选择。微服务架构的优势在于：

#### **模块化设计**：

- **独立模块**：系统的各个核心功能（如视频管理、评论管理、用户管理等）都可以拆分成独立的微服务。每个微服务都可以独立开发、部署和扩展。例如，视频管理模块处理视频上传、存储和播放，评论管理模块处理用户评论和评分，用户管理模块处理注册、登录和权限等。
- **低耦合度**：各模块之间的依赖关系较少，模块可以独立开发和维护，减少了修改一个模块时对其他模块的影响。这使得团队能够并行开发不同模块，提升开发效率。
- **独立扩展**：如果某一模块（如视频管理）因为用户量增多而出现性能瓶颈，便可以单独对该模块进行水平扩展（增加实例）而不影响其他模块。例如，如果视频上传模块的负载增加，可以部署更多的专门处理视频上传和存储的服务。

#### **横向扩展**：

- 微服务架构允许每个服务独立进行 **横向扩展**。这意味着我们可以根据负载的需求，在特定模块上增加更多的实例，而不需要改变整个系统的架构。例如，当用户上传视频量激增时，我们只需要增加视频管理服务的实例，而不需要重新设计整个应用。
- 微服务架构的另一个优势是每个微服务可以根据其特性选择最适合的技术栈。比如，视频处理模块可能使用专门的分布式存储和处理技术，而用户管理模块则可能更加适合使用传统的关系型数据库。

#### **容错性与高可用性**：

- 微服务架构使得系统的高可用性更容易实现。如果某个微服务宕机或出现故障，不会影响到整个系统的运行。我们可以通过负载均衡、自动故障转移等机制保证系统的稳定性。
- 每个微服务可以独立部署并使用独立的数据库或缓存，这降低了单点故障的风险。

#### **通信与数据管理**：

- 各微服务之间通过 **RESTful API** 或 **消息队列（如 Kafka、RabbitMQ）** 进行通信。使用这些轻量级通信协议使得微服务之间的数据交换更为简洁和高效。
- 对于一些不频繁变更的数据，可以使用 **事件驱动架构** 来进行异步处理和数据同步，例如用户数据的变更可以通过消息队列通知其他相关服务。

### **6.2 缓存机制**

为了提高系统的响应速度并减少对数据库的访问压力，我们引入了 **Redis 缓存机制**。Redis 作为一个内存数据库，提供了高效的键值存储功能，特别适合用来缓存频繁访问的数据。

#### **缓存设计**：

1. **缓存热点数据**：
   - **视频数据缓存**：视频的元数据（如视频标题、标签、播放次数等）是用户频繁访问的数据。我们可以将这些元数据存储在 Redis 中，避免每次请求都访问数据库。这样，用户每次查询视频信息时，都会直接从 Redis 中读取，显著提高响应速度。
   - **评论数据缓存**：评论和点赞数据是用户与视频互动的关键，且通常会有较高的访问频率。将热门视频的评论缓存至 Redis 中，能减少数据库的查询次数，提升系统性能。
2. **缓存过期机制**：
   - 为了避免缓存中的数据过时，我们为 Redis 设置 **缓存过期时间**。比如，视频的元数据可以缓存 1 小时，评论数据缓存 5 分钟。缓存时间可以根据实际需求进行调整。
   - 对于频繁更新的数据（如视频观看次数、评论数），缓存会在数据变更时更新（即缓存失效时重新加载数据库中的数据）。
3. **缓存更新策略**：
   - **懒加载（Lazy Loading）**：当用户请求数据时，首先从缓存中查找数据。如果缓存中没有数据，再从数据库中获取并更新缓存。
   - **预加载（Preloading）**：在一些高频访问的模块启动时，预先将相关数据加载到缓存中，避免首次访问时的性能问题。
   - **缓存淘汰策略**：采用 **LRU（Least Recently Used）** 等缓存淘汰策略来管理 Redis 中的数据，当缓存达到最大存储限制时，自动删除最少使用的数据。

#### **缓存与微服务结合**：

- 每个微服务可以单独管理自己的缓存，使用 Redis 作为各个微服务间的缓存层。比如，用户服务的缓存存储用户信息，视频服务的缓存存储视频元数据。
- 微服务之间的缓存可以通过 Redis 的集群功能进行共享，确保各服务访问缓存时的一致性和高效性。

#### **性能提升**：

- 通过 Redis 缓存，我们能够大大降低数据库的读操作负担，特别是对于高频率的查询，如热门视频、评论数量、点赞数量等，能够通过缓存机制快速响应用户请求，从而提升系统的整体性能。
- 对于复杂查询操作，如多条件筛选或聚合操作，缓存能显著减少数据库的计算压力，提升查询速度。

### **总结**

1. **微服务架构**：采用微服务架构可以将系统拆分为多个独立的模块，便于横向扩展和独立部署，确保系统能够应对未来的功能扩展和高并发请求。
2. **缓存机制**：通过 Redis 缓存热点数据，提高系统的响应速度，减少对数据库的访问压力。缓存机制能够有效提升用户体验，并保证系统在高并发情况下的稳定性。

通过微服务架构和缓存机制的设计，我们为系统的可扩展性提供了强有力的支持，确保系统可以在业务需求增长时，轻松进行功能扩展、性能优化与高并发处理。**7. 系统部署架构**

## **7. 系统部署架构**

为确保应用的稳定性、性能和可扩展性，我们采用了云端与容器化部署的混合方案。以下是对前端、后端、数据库和视频存储的具体部署方案：

### **7.1 前端部署**

**部署平台**：**Vercel**

**Vercel** 是一个适用于前端框架（特别是 React、Next.js 等）的云端平台，具有以下优点：

- **自动部署与持续集成（CI）**：
  - 每次代码提交到 GitHub 仓库时，Vercel 会自动触发部署流程，确保最新的前端代码快速发布到生产环境。这样，我们可以在开发和测试时及时看到改动效果，而不需要手动部署。
  - 结合 GitHub Actions，Vercel 可以轻松实现 CI/CD 流程。开发者提交 pull request 时，可以进行自动化测试，确保代码质量。
- **全球分布的 CDN**：
  - Vercel 提供全球内容分发网络（CDN），前端资源（如 JavaScript 文件、图片、样式表）会被自动缓存到多个服务器上。这样，用户访问时可以从最近的服务器获取资源，降低延迟，提升用户体验。
- **无缝的 SSR 和 SSG**：
  - 对于动态内容，Vercel 支持 **服务器端渲染（SSR）** 和 **静态生成（SSG）**，这使得我们能够更灵活地处理页面渲染，提升 SEO 和页面加载速度。
- **扩展性**：
  - Vercel 支持自动扩展，能够根据流量波动自动增减资源。例如，在用户量激增时，Vercel 会自动分配更多的服务器资源，以应对高并发流量。

### **7.2 后端部署**

**部署平台**：**VPS + Docker 容器化部署**

后端服务采用 **VPS（虚拟专用服务器）** 部署，结合 **Docker** 容器化技术，确保开发、测试和生产环境的一致性。Docker 容器化的优势包括：

#### **容器化优势**：

- **环境一致性**：通过 Docker 容器化部署，确保开发环境和生产环境的一致性。开发人员可以在本地创建相同的容器，测试和调试时不再担心与生产环境的差异。
- **便于扩展和维护**：每个微服务都可以在独立的容器中运行，后端服务如视频管理、评论管理、用户管理等都可以独立部署和扩展。当负载增加时，可以轻松通过增加容器实例来进行水平扩展。

#### **高可用性与负载均衡**：

- **Docker Compose**：使用 Docker Compose 管理多容器部署，确保后端服务的相互协调运行。例如，可以为视频服务、用户服务、评论服务等配置单独的容器，并通过 Docker Compose 定义服务之间的依赖关系。
- **负载均衡**：可以使用 Nginx 作为负载均衡器，将流量分发到多个后端容器实例，实现高可用性。负载均衡确保在服务器发生故障或请求量激增时，流量能够均匀地分配到不同的容器实例上，保证服务的高可用性。

#### **安全性**：

- 使用 **SSL/TLS 加密** 保护后端服务与客户端之间的通信，确保数据传输的安全性。
- **防火墙和安全组配置**：通过防火墙规则限制访问，仅允许特定的端口和 IP 地址访问后端服务。

### **7.3 数据库部署**

**部署平台**：**VPS + PostgreSQL**

数据库使用 **PostgreSQL**，并部署在 **VPS** 上，以下是数据库部署的要点：

#### **高可用性与冗余**：

- **主从复制**：使用 **主从复制** 配置，主库负责写操作，从库负责读操作，这样可以有效分担数据库负载，提高查询性能。
- **自动故障转移**：如果主库发生故障，系统能够自动切换到从库，确保数据库的高可用性。通过配置数据库的 **Failover** 机制，实现容灾能力。
- **备份策略**：定期对数据库进行备份，确保数据的安全性。备份可以存储在异地服务器或云存储中，以防止数据丢失。

#### **安全性**：

- **加密存储**：使用加密存储敏感数据（如用户密码、视频文件的元数据等），确保数据在存储过程中不会被泄露。
- **权限控制**：通过 PostgreSQL 的角色和权限管理，确保只有授权的用户可以访问和修改数据库中的敏感数据。

#### **性能优化**：

- **索引优化**：为高频查询的数据表（如视频信息、评论信息等）建立索引，优化查询性能。
- **连接池**：通过使用连接池技术（如 **pgbouncer**），减少数据库连接的开销，提升并发访问性能。

### **7.4 视频存储**

**存储平台**：**Cloudinary**

视频文件存储使用 **Cloudinary**，这是一种强大的云媒体管理平台，支持视频的上传、存储、处理和优化，具有以下优势：

#### **视频上传与存储**：

- **视频压缩与优化**：Cloudinary 提供自动压缩和格式转换功能，能够将视频文件压缩到适合网页播放的大小，同时确保视频质量。它支持多种格式（如 MP4、WebM 等）和多种分辨率，以适应不同设备和网络条件下的播放需求。
- **CDN 加速**：视频存储在 Cloudinary 上后，系统自动使用 **全球内容分发网络（CDN）**，确保用户能够从最近的服务器快速获取视频内容，减少加载时间和延迟。

#### **视频处理与优化**：

- **实时处理**：Cloudinary 提供实时的视频处理功能，可以在用户播放视频时对视频进行即时调整，如改变分辨率、裁剪、加水印等。这样可以根据用户需求提供个性化的视频播放体验。
- **支持多平台播放**：Cloudinary 确保视频文件可以在桌面端、移动端等不同设备上无缝播放，确保跨平台兼容性。

#### **安全性**：

- **上传权限控制**：视频上传操作需要进行身份认证，确保只有经过授权的用户可以上传视频。
- **视频加密与访问控制**：Cloudinary 提供加密存储和权限管理功能，确保视频内容在存储和传输过程中受到保护，防止未授权访问。

### **总结**

- **前端部署**：Vercel 提供了自动化部署和全球 CDN 支持，保证前端应用的快速响应和扩展性。
- **后端部署**：后端服务通过 Docker 容器化部署，结合 VPS 托管，确保服务的高可用性、可扩展性和环境一致性。
- **数据库部署**：PostgreSQL 部署在 VPS 上，通过主从复制、自动故障转移和定期备份等机制，确保数据库的高可用性和数据安全。
- **视频存储**：Cloudinary 提供高效的视频上传、存储和优化功能，结合 CDN 加速和安全存储，保证视频播放流畅和安全。

通过这样的部署架构设计，系统能够高效、稳定地服务于用户，同时具备良好的扩展性和维护性，满足未来的业务增长需求。

## **8. 监控与日志**

在现代应用中，**监控**和**日志**是确保系统稳定性、性能和安全性的重要组成部分。通过有效的监控，我们能够及时发现并解决潜在的问题，而日志则能为后续的故障排除提供详细的背景信息。以下是针对 **前端** 和 **后端** 的监控与日志设计方案：

### **8.1 前端监控**

**监控工具**：**LogRocket**

**LogRocket** 是一个强大的前端监控工具，专注于用户行为跟踪和前端性能分析。它不仅提供了错误日志记录功能，还能帮助开发者深入了解用户交互和页面加载的全过程，以下是其优势：

#### **用户行为监控**：

- **页面录制**：LogRocket 可以录制用户在应用中的每一次操作，帮助开发者重现用户的实际行为。通过回放用户的浏览过程，可以快速发现并解决用户遇到的问题。
- **点击、滚动、输入跟踪**：LogRocket 跟踪用户在页面上的每一个交互事件，如点击按钮、滚动页面、表单输入等。这些信息有助于开发者分析用户的操作流，识别潜在的体验问题。

#### **错误监控与性能分析**：

- **错误追踪**：LogRocket 自动捕捉 JavaScript 错误并将其记录，详细描述错误的发生地点、堆栈信息、影响的用户等。这使得前端开发人员能够快速定位和解决 Bug。
- **性能瓶颈检测**：LogRocket 能够监控前端性能问题，如页面加载时间、渲染速度、资源请求的响应时间等。通过分析这些数据，开发者可以优化前端性能，提高用户体验。
- **资源加载分析**：监控各类静态资源的加载时间（如图片、脚本文件等），帮助开发者识别可能影响页面加载的瓶颈，进行优化。

#### **集成与报告**：

- **与 GitHub 集成**：LogRocket 支持与 GitHub 集成，开发者可以直接将错误信息和性能瓶颈与代码提交联系起来，方便问题追踪。
- **实时警报与通知**：当发生重要的前端错误或性能瓶颈时，LogRocket 可以通过 Slack、邮件等渠道进行实时通知，确保开发人员能够及时处理问题。

### **8.2 后端监控**

**监控工具**：**Prometheus + Grafana**

对于后端服务的监控，我们选用了 **Prometheus** 和 **Grafana** 这两个工具的组合。Prometheus 是一个开源的监控系统，用于采集和存储时序数据，而 Grafana 是一个开源的分析平台，用于可视化这些数据。

#### **Prometheus**：

- **数据采集**：Prometheus 定期从各个监控端点（如应用服务器、数据库等）抓取监控数据。对于每个服务，Prometheus 会通过 HTTP 请求采集指标数据（例如，服务的请求次数、响应时间、错误率等）。
- **多维度数据**：Prometheus 提供了多维度的数据模型，能够根据不同的标签对数据进行细分。例如，可以根据 API 路径、请求类型、服务器实例等标签对请求数据进行聚合，方便分析不同服务、模块的健康状态。
- **警报机制**：Prometheus 支持设置警报规则，一旦某个监控指标超出设定的阈值，Prometheus 会通过邮件、Slack 或者其他通知渠道发送警报。比如，如果 CPU 使用率超过 80%、某个 API 错误率超过 5% 等，都会触发警报，提示开发团队及时干预。

#### **Grafana**：

- **数据可视化**：Grafana 与 Prometheus 集成后，可以实时展示 Prometheus 收集到的数据。通过 Grafana 的仪表盘，开发和运维团队可以方便地查看各种服务的健康状况和性能指标。例如，查看请求的平均响应时间、数据库查询的执行时间、服务器的负载情况等。
- **定制化仪表盘**：Grafana 提供强大的仪表盘功能，用户可以根据需要自定义不同的仪表盘，展示具体的性能指标。可以针对每个微服务、数据库、缓存等模块创建独立的仪表盘，清晰地展示每个部分的健康状况。
- **实时监控**：Grafana 提供实时的监控视图，帮助团队及时察觉系统中潜在的性能瓶颈或故障，并快速响应。

#### **常见监控指标**：

- **请求量**：每秒、每分钟或每小时的请求数量，帮助评估服务的负载。
- **响应时间**：请求的平均响应时间，能够反映服务的性能水平。
- **错误率**：各类错误的发生频率，帮助识别系统的潜在问题。
- **CPU 和内存使用率**：监控服务器资源使用情况，避免资源过载。
- **数据库查询性能**：数据库的查询响应时间，帮助优化数据库性能。
- **缓存命中率**：监控 Redis 等缓存的命中率，帮助分析缓存的使用效率。

#### **集成与自动化**：

- **集成告警系统**：通过 Grafana，开发团队可以为特定指标配置阈值，一旦超过阈值就会触发告警。这些告警可以通过邮件、Slack、Webhook 等方式发送通知，确保团队及时响应系统问题。
- **自动化修复**：与告警系统集成后，可以在特定情况下自动触发修复脚本，自动重启服务、扩展资源等，减轻人工干预的负担。

### **8.3 日志管理**

为了更好地分析和追踪系统运行状况，我们还需要全面的日志管理方案。

#### **前端日志**：

- **捕获前端错误**：使用 **Sentry** 或 **LogRocket** 捕获前端错误。它们提供详细的错误堆栈跟踪，帮助开发人员迅速定位和修复问题。
- **用户行为日志**：在前端使用事件跟踪工具（如 **Google Analytics** 或 **Mixpanel**）记录用户交互数据，帮助分析用户行为、页面访问量、转化率等关键指标。

#### **后端日志**：

- **日志收集**：在后端服务中，可以使用 **Winston** 或 **Bunyan** 等日志框架来记录日志。通过设置适当的日志级别（如 INFO、WARN、ERROR），可以帮助开发和运维团队清晰地了解系统的运行情况。
- **集中化日志管理**：使用 **ELK（Elasticsearch、Logstash、Kibana）** 或 **Graylog** 等日志集中管理工具，将后端日志集中存储并进行可视化。通过这些工具，团队可以方便地查询日志，进行故障排除和性能分析。
- **日志存储与分析**：日志应存储在一个高可用、易于扩展的系统中，并支持按需查询。通过分析日志数据，能够及时发现系统瓶颈、用户行为异常等问题。

### **总结**

- **前端监控**：LogRocket 提供强大的用户行为监控、错误捕获和性能分析功能，帮助开发团队迅速定位并解决前端问题。
- **后端监控**：Prometheus 和 Grafana 的组合提供了全面的后端性能监控，包括请求量、响应时间、错误率等关键指标。它们的集成告警系统可以确保团队及时处理问题。
- **日志管理**：通过 Sentry、LogRocket、Winston 和 ELK 等工具，确保前后端日志的有效收集、存储和分析，帮助开发团队进行故障排除和优化。

通过完善的监控与日志设计，系统可以在运行过程中实时监控健康状态，及时发现并解决问题，从而保证系统的稳定性、性能和用户体验。

## **9. 结论**

本系统的架构设计围绕**高可用性**、**可扩展性**和**高性能**展开，确保能够满足日益增长的用户需求，并为未来功能的拓展提供了强有力的技术支持。以下是系统架构设计的总结：

### **前后端分离架构**

系统采用了现代化的前后端分离架构，前端使用 Vue 3 搭配 Vite 构建，后端采用 Express.js 进行业务逻辑处理。这种架构的优势在于：

- **前端开发效率高**：Vue 3 的响应式设计和组件化开发让前端开发更加高效，Vite 的极速构建增强了开发体验。
- **后端灵活高效**：Express.js 轻量而强大，适合处理大量 HTTP 请求，支持中间件的扩展性，使得后端开发更加简洁和高效。
- **解耦合与易于维护**：前后端分离提高了系统的模块化，前端和后端可以独立开发、部署和扩展，降低了系统的耦合度，提升了维护性。

### **技术选型**

系统选择了业界成熟的技术栈，包括：

- **Vue 3 + Vite**：提供优秀的开发体验和性能，支持组件化开发和现代化的前端构建。
- **Tailwind CSS**：简洁高效的 CSS 框架，通过实用类快速构建响应式界面。
- **Ant Design + Naive UI**：提供功能丰富且美观的 UI 组件，帮助构建一致且友好的用户界面。
- **Express.js + PostgreSQL**：强大的后端支持，Express.js 简化了 API 开发，PostgreSQL 提供了高效、可靠的数据存储与查询能力。
- **Redis + Cloudinary**：用于提高数据缓存性能（Redis）和视频存储与优化（Cloudinary）。
- **Docker + VPS**：容器化部署提高了环境的一致性和灵活性，VPS 提供了可定制的服务器资源。

### **可扩展性与高可用性**

本系统的设计充分考虑了未来的可扩展性和高可用性：

- **模块化设计**：系统采用模块化设计，使得各个功能模块能够独立开发、部署和扩展。例如，视频管理、评论管理等可以独立为微服务，方便横向扩展。
- **微服务架构支持**：随着业务需求增长，系统能够根据需要拆分出独立的微服务进行水平扩展，提高系统的可扩展性。
- **缓存机制与数据库优化**：Redis 的缓存机制减少了对数据库的频繁访问，提升了系统的响应速度；PostgreSQL 提供了高效的数据查询能力，支持复杂查询与事务处理。

### **系统安全性**

系统在设计上重视安全性，采取了以下措施：

- **JWT + Auth.js** 进行身份认证与授权，确保用户安全访问。
- **bcrypt** 对用户密码进行加密，保护用户隐私。
- **防御措施**：通过 ORM 预防 SQL 注入，使用输入过滤和 HTML 编码防止 XSS 攻击，使用 CSRF token 保护系统免受 CSRF 攻击。

### **监控与日志管理**

为了保障系统的稳定性和性能，本系统设计了完善的监控与日志机制：

- **前端监控**：LogRocket 提供了强大的用户行为监控、错误捕捉和性能分析功能。
- **后端监控**：Prometheus 和 Grafana 提供了详细的性能指标和实时监控，能够帮助团队监测系统健康状态。
- **日志管理**：通过集中化的日志收集与分析（ELK），开发团队能够快速定位和修复故障。

### **系统部署与运维**

系统采用现代化的部署方式，确保高效、灵活的运维管理：

- **前端部署**：通过 Vercel 实现前端自动部署和持续集成。
- **后端部署**：使用 Docker 容器化后端应用，确保开发、测试、生产环境的一致性，并部署在 VPS 上，提供可定制化的资源配置。
- **数据库部署**：PostgreSQL 部署在 VPS 上，支持高可用性配置，确保数据安全性和可靠性。
- **视频存储**：使用 Cloudinary 存储和优化视频，提升平台的视频处理和播放性能。

### **总结**

通过前后端分离架构、模块化设计、微服务支持、缓存与数据库优化等手段，本系统具备了极强的可扩展性和高可用性，能够应对未来功能扩展和用户增长的挑战。此外，系统设计在安全性、监控、日志管理和部署等方面也做了充分的考虑，确保了系统的稳定性与安全性。最终，系统具备了高效、可扩展和易维护的特点，能够为用户提供流畅的体验和高质量的服务。



```
将这个系统上午图的代码转化成diagrams所需要的代码，并给出文件命名
系统上下文图

graph TD
  User[👤 用户] -->|访问| Frontend[🌐 Vue 3 + Vite]
  Frontend -->|API 请求| Backend[🖥️ Express.js + TypeScript]
  
  Backend -->|身份认证| Auth[🔐 Auth.js (JWT)]
  Backend -->|数据库查询| DB[🗄️ PostgreSQL]
  Backend -->|缓存数据| Cache[⚡ Redis]
  Backend -->|上传视频| VideoStorage[📦 Cloudinary]
  
  Backend -->|日志监控| LogFrontend[📊 LogRocket]
  Backend -->|后端监控| LogBackend[📈 Prometheus + Grafana]

  subgraph CI/CD & 部署
    GitHubActions[🚀 GitHub Actions] -->|自动部署| Vercel[🌍 Vercel (前端)]
    GitHubActions -->|自动部署| VPS[🏢 VPS (后端)]
  end
  
  Frontend -->|静态资源| Vercel
  VideoStorage -->|视频优化| CDN[🖼️ Cloudinary CDN]
```

```
容器图

graph TD
  subgraph User Device
    User[👤 用户]
  end

  subgraph Frontend
    Browser[🌐 Vue 3 + Vite]
  end

  subgraph Backend
    API[🖥️ Express.js API]
    Auth[🔐 Auth.js (JWT)]
    Cache[⚡ Redis]
    DB[🗄️ PostgreSQL]
  end

  subgraph Storage
    VideoStorage[📦 Cloudinary]
  end

  subgraph Monitoring
    LogFrontend[📊 LogRocket]
    LogBackend[📈 Prometheus + Grafana]
  end

  subgraph CI/CD Deployment
    GitHubActions[🚀 GitHub Actions]
    Vercel[🌍 Vercel (前端)]
    VPS[🏢 VPS (后端)]
  end

  User -->|访问| Browser
  Browser -->|API 请求| API

  API -->|身份认证| Auth
  API -->|查询数据| DB
  API -->|缓存数据| Cache
  API -->|存储视频| VideoStorage

  API -->|日志监控| LogBackend
  Browser -->|用户行为监控| LogFrontend

  GitHubActions -->|自动部署| Vercel
  GitHubActions -->|自动部署| VPS

```

```
组件图
graph TB
    subgraph Frontend
        FE1[Vue.js] --> FE2[Components]
        FE2 --> FE3[API Requests]
        FE3 --> FE4[User Authentication]
        FE4 --> FE5[Video Playback]
        FE5 --> FE6[Comments & Likes]
        FE6 --> FE7[User Profile]
    end

    subgraph Backend
        BE1[Express.js] --> BE2[API Routes]
        BE2 --> BE3[JWT Authentication]
        BE3 --> BE4[Video Service]
        BE4 --> BE5[Database (PostgreSQL)]
        BE5 --> BE6[File Storage (Cloudinary)]
        BE4 --> BE7[Video Metadata]
        BE7 --> BE8[Video Upload/Management]
        BE8 --> BE9[Admin Management]
    end

    subgraph Database
        DB1[PostgreSQL] --> DB2[Users Table]
        DB2 --> DB3[Videos Table]
        DB3 --> DB4[Comments Table]
        DB4 --> DB5[Likes Table]
        DB5 --> DB6[Tags Table]
    end

    subgraph Storage
        S1[Cloudinary] --> S2[Video Files]
        S1 --> S3[Optimized Video Storage]
    end

    Frontend -->|Calls APIs| Backend
    Backend -->|Saves Data| Database
    Backend -->|Uses Files| Storage
    Backend -->|Provides Data| Frontend
    Backend -->|Authenticates| Frontend


```

```
API路由图

graph TD
    A[用户相关接口] --> A1[POST /api/auth/register 用户注册]
    A --> A2[POST /api/auth/login 用户登录]
    A --> A3[POST /api/auth/logout 用户登出]
    A --> A4[GET /api/users/me 获取当前用户信息]
    A --> A5[PUT /api/users/me 更新当前用户信息]

    B[视频相关接口] --> B1[GET /api/videos 获取所有视频列表]
    B --> B2[GET /api/videos/:id 获取单个视频信息]
    B --> B3[POST /api/videos 上传视频]
    B --> B4[PUT /api/videos/:id 修改视频信息]
    B --> B5[DELETE /api/videos/:id 删除视频]
    B --> B6[GET /api/videos/search 搜索视频]

    C[评论相关接口] --> C1[GET /api/videos/:id/comments 获取某个视频的评论列表]
    C --> C2[POST /api/videos/:id/comments 添加评论]
    C --> C3[PUT /api/comments/:id 修改评论]
    C --> C4[DELETE /api/comments/:id 删除评论]

    D[视频审核相关接口] --> D1[GET /api/videos/reviews 获取所有视频审核列表]
    D --> D2[POST /api/videos/:id/review 提交视频审核]
    D --> D3[PUT /api/videos/:id/review 修改视频审核状态]

    E[用户行为统计接口] --> E1[GET /api/users/activities 获取用户的行为统计数据]
    E --> E2[GET /api/videos/stats 获取视频的观看数据]

    A1 --> F[游客]
    A2 --> F
    A3 --> G[会员/管理员]
    A4 --> G
    A5 --> G

    B1 --> F
    B2 --> F
    B3 --> G
    B4 --> G
    B5 --> G
    B6 --> F

    C1 --> F
    C2 --> G
    C3 --> G
    C4 --> G

    D1 --> H[管理员]
    D2 --> H
    D3 --> H

    E1 --> H
    E2 --> H

```

```
部署图

graph TD
    subgraph 前端
        A[前端应用 (Vercel)] --> B[Cloudflare (CDN)]
    end
    
    subgraph 后端
        C[后端应用 (VPS)] --> D[Express.js]
        C --> E[PostgreSQL]
        C --> F[Redis]
        C --> G[Cloudinary]
    end

    subgraph 管理工具
        H[GitHub Actions (CI/CD)]
    end

    subgraph 日志监控
        I[LogRocket (前端监控)]
        J[Prometheus + Grafana (后端监控)]
    end

    A -->|请求| C
    B -->|静态资源请求| A
    D -->|数据库操作| E
    D -->|缓存操作| F
    D -->|视频存储| G
    H -->|部署与CI/CD| C
    I -->|日志监控| A
    J -->|监控数据| C

    E -->|数据库连接| C
    F -->|缓存连接| C

```

